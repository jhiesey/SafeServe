-- runProgMonadic = do
--  resApp <- io (runProg "DynamicTest")
--  case resApp of
--    Left ap -> text $ "SUCCESS"
--    Right fa -> text $ B.pack fa
--   -- pt <- io (runProg "DynamicTest" >>= return . B.pack)
--  -- text $ B.pack "pt"
-- 
-- runProg :: String -> IO (Either Sf.Application String)
-- runProg modName = do
--   status <- make (modName++".hs") ["-iapi", "-XSafe"]
--   putStrLn $ show status
--   case status of
--     MakeSuccess _ _ -> f
--     MakeFailure e -> return $ Right $ intercalate "\n" e
--   
--   where
--     f = do 
--       loadStatus <- pdynload_ (modName++".o") ["api"] [] ["-XSafe"] "API.Interface" "resource"
--       case loadStatus of
--         LoadFailure msg -> return $ Right $ show msg
--         LoadSuccess mod v -> do
--          let resApp = function v
--           -- resApp `deepseq` unload mod
--          unload mod
--          return $ Left $ resApp
 
 
-- runAsMiddleware :: Sf.Application -> Hk.Middleware
-- runAsMiddleware = undefined


-- src     = "Plugin.hs"
-- -- wrap    = "../Wrapper.hs"
-- apipath = "api"
-- 
-- dynload2 :: IO ()
-- dynload2 = do
--   status <- make src ["-i"++apipath, "-XSafe"]
--   case status of
--     MakeSuccess _ _ -> f
--     MakeFailure e -> mapM_ putStrLn e
-- 
--   where
--     f = do
--       putStrLn "Trying to load"
--       v <- pdynload_ "Plugin.o" ["api"] [] ["-XSafe"] "API.Interface" "resource"
--       putStrLn "Tried loading"
--       case v of
--         LoadSuccess _ a  -> do
--           putStrLn "loaded .. yay!"
--           putStrLn $ function a
--         LoadFailure msg  -> putStrLn "failed"  >> print msg
