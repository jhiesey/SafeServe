\title{SafeServe: User-Editable Websites in Haskell}
\author{
        John Hiesey \\
        jhiesey@cs.stanford.edu
}
\date{\today}

\documentclass[12pt]{article}
\usepackage[margin=1.0in]{geometry}

\begin{document}
\maketitle

% \begin{abstract}
% This is the paper's abstract \ldots
% \end{abstract}

\section{Introduction}
Traditionally, websites are written in a scripting language,
such as Python, Ruby, or PHP and edited in a standalone text
editor before being manually uploaded to the server.
The owner of a server must either trust the developers of the site,
or carefully use operating system-level permissions to ensure that
the site cannot harm the rest of the system.  Therefore, it is not
very safe to allow untrusted users to edit sites written in
traditional web scripting languages from a browser.

As an alternative, Content Management Systems (CMSs) such as
WordPress, allow even non-technical users to edit sites through
a web browser.  Unfortunately, this technique doesn't allow any
changes to be made to the behavior of a site, only to the content.

Using SafeHaskell, however, we can allow users to edit the server-side
code while ensuring at the language level that whatever code they
write will be safe to execute.

\section{SafeServe User Interface}
SafeServe can be run from the command line, and once started, listens
(currently on port 3000) for HTTP requests.  A site can be created
or edited simply by visiting \verb+http://<hostname>/edit/<site_name>+ in a browser,
where \verb+<site_name>+ is the name of the site the user wants to create.
Since this will also be the name of the associated Haskell module,
it must start with a capital letter and contain no punctuation; otherwise,
it will be automatically adjusted or corrected.

The user is then presented with an editor, which uses the Codemirror JavaScript
library for syntax highlighting, as well as ``Save'' and ``Run!'' buttons.
The ``Run!'' button simply points to \verb+http://<hostname>/run/<site_name>+,
which is the root of the plugin's site.  From there, the user can interact
directly with the generated site.

\section{SafeServe Application Interface}
A SafeServe application is simply a single Haskell source file that follows
the following rules:
\begin{enumerate}
\item It must be able to be compiled with -XSafe.  Any other programs will be rejected.

\item It must define a module of the same name as the site name.

\item It must define an object called ``resource'' with the following type, defined in the
top-level module API:
\begin{verbatim}
  data Interface = Interface { 
          function :: Application
  }
\end{verbatim}
\end{enumerate}
where Application is defined in module ``SafeBase.Framework'' as follows:
\begin{verbatim}
type Application = Env -> RIO Response
\end{verbatim}
Env and Response are data types corresponding to the information received in an HTML
request and provided back in an HTML response, RIO is a restricted IO monad, which
will be described later.

Here is a minimal example of a plugin:

\begin{verbatim}
  {-# LANGUAGE OverloadedStrings #-}

  module Simple where

  import API
  import SafeBase.Framework as F
  import SafeBase.RIO
  import qualified SafeBase.ByteString.Char8 as B

  resource = Interface { function = theApp }

  theApp :: Application
  theApp =  F.safeserve $ do

    F.get "/" $ do
      F.html "<html><head><title>A Minimal Example</title>
      </head><body>Hello, world</body></html>"  
\end{verbatim}

Within the plugin, the RIO monad can be used for very limited IO, as
provided by the functions in the``SafeBase.RIO'' module.

Each plugin is provided with a directory which it can access,
and access is limited to only this directory.  At this point, reading and
writing files, as well as getting the current time, are the only permitted
operations.  Expanding the capabilities of the RIO monad would be a
particularly useful way to extend SafeServe in the future.

Various other functionality, most of which is a subset of that provided by the
Miku web framework, is also available.  A slightly modified version of the
Blaze template combinator library is also available through importing
the SafeBlaze package provided with SafeServe.

\section{Implementation}

\subsection{Existing functionality}
A number of existing libraries and frameworks were crucial in implementing SafeServe.
An overview of the most important ones are here, see their documentation CITE HERE
for more details.
\paragraph{SafeHaskell}
SafeHaskell is a Haskell extension that ensures that a Haskell program
is actually type-safe.  The key idea is to reject any program that uses
unsafe functions, such as unsafePerformIO or unsafeCoerce and any
program that imports such a module.  This checking is enabled with the -XSafe
option in GHC.

If a module uses unsafe modules but only exports a safe interface, the
module can be compiled with -XTrustworthy to mark it as safe to import into
other safe modules.

\paragraph{Miku}
In order to provide a reasonable interface to the users of SafeServe, we
decided to base it on an existing Haskell web framework.  Of the frameworks
listed on the Haskell Wiki page, the most popular were judged to be too
complex to modify for this project.  To make SafeHaskell useful, sites
must in particular not be allowed to access the IO monad.  Happstack and
Snap, both popular frameworks, are complex in terms of code size and
rely heavily on constant access to the IO monad.  These two, and especially
Yesod, another Haskell web framework, rely on Template Haskell as well,
which cannot easily be made safe.

To avoid these problems, we used Miku, a relatively simpler Haskell
web framework that relies only minimally on the IO monad and Template Haskell
in its core.

\paragraph{hs-plugins}
Once the user supplies a program to run, it must be compiled and run.
In order to provide an easy interface between the SafeServe server code
and the user's code, we decided to load and run the user's code inside
the main server process.

In order to dynamically compile and load haskell code, we used the hs-plugins
module.  It provides both an interface to GHC to compile the user's source
file and, more importantly, an interface to dynamically load the module into
the running Haskell process.

The simplest interface to the loader has the following type signature:

\begin{verbatim}
load :: FilePath -> [FilePath] -> [PackageConf] -> Symbol -> IO (LoadStatus a)
\end{verbatim}

where the input types are all newtypes for String.  Unfortunately, this does
no type checking, so even if SafeHaskell is enabled when compiling the plugin,
safety can be violated by having the server evaluate a function of the wrong
type provided in a plugin.

The hs-plugins module has a few options to solve this problem, but the one
most useful here is an alternative loading function with the following type
signature:

\begin{verbatim}
pdynload_ :: FilePath -> [FilePath] -> [PackageConf] -> [Arg] ->
  Type -> Symbol -> IO (LoadStatus a)
\end{verbatim}

Although this function is still polymorphic in its return type,
it ensures that the called function has the type specified by its
Type argument, as a string.  It accomplishes this by dynamically creating
a Haskell source file that attempts to import the plugin file and
call the function with the type supplied by the user.  The result
of the type checking process is used as an indicator of whether the plugin
provides the correctly-typed export--if so, that function is loaded as
before, and if not, the dynamic load fails.

\subsection{Architecture}
The actual SafeServe application is itself a site hosted within an unmodified
version of Miku, and is located in file SafeServe.hs.  This application handles
reading, writing, loading, and running the SafeServe sites that it hosts.
It also directly serves the static files belonging to each application.

All source files and static files belonging to a particular plugin are
located in the ``\verb+plugins/<plugin_name>+'' directory.  Due to limitations on form
uploads in Miku, there is currently no way to upload static files for an application.
Until this is remedied, these files can be manually put in place (with access to the
server), or a Haskell program which writes the correct file could be written within in the plugin.
Submitting a patch to the Miku codebase would be the best way to fix this limitation.


The other substantial component of SafeServe is the SafeBase module, which provides
a safe, but substantially reduced, subset of the functionality from Miku.  The
entire module is compiled with -XTrustworthy, as its interface has been carefully
selected to be safe.  Nonetheless, ideally SafeBase would be split into two modules,
the smaller of which would contain all unsafe imports and be compiled with -XTrustworthy,
and the larger of which would import modules from the the first and be compiled with
-XSafe.  This would provide better automatic checking of the safety of the interface
exported by SafeBase.

SafeBase itself contains a few modules: SafeBase.ByteString is a version of the Data.ByteString
package, with all but a few unsafe functions reexported.  The other two submodules,
SafeBase.Framework and SafeBase.RIO, will be described in the next subsections.

\subsection{SafeBase.Framework}
This module provides a sanitized and condensed version of the Miku framework.  For simplicity,
the entire implementation resides in a single module, which provides both the data types and
functions that are needed to build a website.  In order to avoid the IO monad entirely,
many of the core data structures used by Miku are modified, such as the Env (representing an
HTTP request) and Response (representing an HTTP response).  For simplicity of implementation,
their fields are also simplified somewhat.  A few safe types are, however, directly
imported from Miku.

Like in Miku, much of the code resides in the AppMonad, which in this case has the following type:

\begin{verbatim}
ReaderT Env (ST.StateT Response RIO) ()
\end{verbatim}

The State monad keeps allows the code to build up the response, while the Reader monad gives
it access to the request.  Finally, the RIO monad provides limited IO.

In order to actually execute the plugins' web handlers, the top-level SafeServe application
converts Miku's requests into SafeServe's request format, and then converts the results
back into Miku's native format.

\subsection{SafeBase.RIO}



% \paragraph{Outline}
% The remainder of this article is organized as follows.
% Section~\ref{previous work} gives account of previous work.
% Our new and exciting results are described in Section~\ref{results}.
% Finally, Section~\ref{conclusions} gives the conclusions.

% \section{Previous work}\label{previous work}
% A much longer \LaTeXe{} example was written by Gil~\cite{Gil:02}.

\section{Results}\label{results}
In this section we describe the results.

\section{Conclusions}\label{conclusions}
We worked hard, and achieved very little.

\bibliographystyle{abbrv}
\bibliography{main}


\end{document}
This is never printed